<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · Polylogarithms.jl</title><meta name="title" content="Home · Polylogarithms.jl"/><meta property="og:title" content="Home · Polylogarithms.jl"/><meta property="twitter:title" content="Home · Polylogarithms.jl"/><meta name="description" content="Documentation for Polylogarithms.jl."/><meta property="og:description" content="Documentation for Polylogarithms.jl."/><meta property="twitter:description" content="Documentation for Polylogarithms.jl."/><meta property="og:url" content="https://matthew.roughan@adelaide.edu.au.github.io/Polylogarithms.jl/"/><meta property="twitter:url" content="https://matthew.roughan@adelaide.edu.au.github.io/Polylogarithms.jl/"/><link rel="canonical" href="https://matthew.roughan@adelaide.edu.au.github.io/Polylogarithms.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Polylogarithms.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mroughan/Polylogarithms.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mroughan/Polylogarithms.jl/blob/master/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#Polylogarithms">Polylogarithms</a></li></ul><h1 id="Polylogarithms"><a class="docs-heading-anchor" href="#Polylogarithms">Polylogarithms</a><a id="Polylogarithms-1"></a><a class="docs-heading-anchor-permalink" href="#Polylogarithms" title="Permalink"></a></h1><ul><li><a href="#Polylogarithms.Polylogarithms"><code>Polylogarithms.Polylogarithms</code></a></li><li><a href="#Base.parse-Union{Tuple{T}, Tuple{Type{Complex{T}}, AbstractString}} where T&lt;:Real"><code>Base.parse</code></a></li><li><a href="#Polylogarithms.bernoulli-Tuple{Integer}"><code>Polylogarithms.bernoulli</code></a></li><li><a href="#Polylogarithms.bernoulli-Tuple{Integer, Real}"><code>Polylogarithms.bernoulli</code></a></li><li><a href="#Polylogarithms.clearcache-Tuple{}"><code>Polylogarithms.clearcache</code></a></li><li><a href="#Polylogarithms.dilog-Tuple{Number}"><code>Polylogarithms.dilog</code></a></li><li><a href="#Polylogarithms.dirichlet_beta-Tuple{Number}"><code>Polylogarithms.dirichlet_beta</code></a></li><li><a href="#Polylogarithms.euler-Tuple{Integer}"><code>Polylogarithms.euler</code></a></li><li><a href="#Polylogarithms.harmonic-Tuple{Integer, Integer}"><code>Polylogarithms.harmonic</code></a></li><li><a href="#Polylogarithms.harmonic-Tuple{Integer}"><code>Polylogarithms.harmonic</code></a></li><li><a href="#Polylogarithms.harmonic-Tuple{Integer, Real}"><code>Polylogarithms.harmonic</code></a></li><li><a href="#Polylogarithms.harmonic-Tuple{Union{Float64, ComplexF64}}"><code>Polylogarithms.harmonic</code></a></li><li><a href="#Polylogarithms.polylog-Tuple{Number, Number, Diagnostics}"><code>Polylogarithms.polylog</code></a></li><li><a href="#Polylogarithms.polylog-Tuple{Number, Number}"><code>Polylogarithms.polylog</code></a></li><li><a href="#Polylogarithms.polylog_ds-Tuple{Number, Number}"><code>Polylogarithms.polylog_ds</code></a></li><li><a href="#Polylogarithms.polylog_dz-Tuple{Number, Number}"><code>Polylogarithms.polylog_dz</code></a></li><li><a href="#Polylogarithms.rogers-Tuple{Number}"><code>Polylogarithms.rogers</code></a></li><li><a href="#Polylogarithms.spence-Tuple{Number}"><code>Polylogarithms.spence</code></a></li><li><a href="#Polylogarithms.stieltjes-Tuple{Integer}"><code>Polylogarithms.stieltjes</code></a></li><li><a href="#Polylogarithms.tetralog-Tuple{Number}"><code>Polylogarithms.tetralog</code></a></li><li><a href="#Polylogarithms.trilog-Tuple{Number}"><code>Polylogarithms.trilog</code></a></li><li><a href="#SpecialFunctions.zeta-Tuple{Number, Memoization}"><code>SpecialFunctions.zeta</code></a></li></ul><article><details class="docstring" open="true"><summary id="Polylogarithms.Polylogarithms"><a class="docstring-binding" href="#Polylogarithms.Polylogarithms"><code>Polylogarithms.Polylogarithms</code></a> — <span class="docstring-category">Module</span></summary><section><div><pre><code class="language-julia hljs">Polylogarithms</code></pre><p>Module containing functions to calculate the polylogarithm and associated functions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mroughan/Polylogarithms.jl/blob/4cb7747e85fcc7e310e8d23e1635cb8be7b6611b/src/Polylogarithms.jl#L1-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Polylogarithms.clearcache-Tuple{}"><a class="docstring-binding" href="#Polylogarithms.clearcache-Tuple{}"><code>Polylogarithms.clearcache</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">clearcache()</code></pre><p>Note that in this library the zeta function has been replaced by a wrapper that looks up (or stores) the value into a cache, so that we don&#39;t have to repeat zeta function calculations. This function clears the cache so that you can obtain accurate &quot;first run&quot; performance measurements. It should not be needed in day-to-day calculations unless it is used a great deal and the cache starts taking up too much memory. </p><p>See also <code>zeta(s, ::Memoization )</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mroughan/Polylogarithms.jl/blob/4cb7747e85fcc7e310e8d23e1635cb8be7b6611b/src/polylog.jl#L15-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Polylogarithms.polylog-Tuple{Number, Number, Diagnostics}"><a class="docstring-binding" href="#Polylogarithms.polylog-Tuple{Number, Number, Diagnostics}"><code>Polylogarithms.polylog</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">polylog(s, z, Diagnostics())</code></pre><p>Calculates the Polylogarithm function <span>${Li}_s(z)$</span> defined by</p><p><span>${Li}_s = \displaystyle  \sum_{n=1}^{\infty} \frac{z^n}{n^s},$</span></p><p>or by analytic extension to the complex plane. </p><p>It uses double precision complex numbers (not arbitrary precision). It&#39;s goal is an relative error bound <span>$10^{-12}$</span> though there is a keyword <code>accuracy</code> that allows you to change this.</p><p>This version outputs some additional diagnostic information that is useful in debugging, but unlikely to be useful in everyday calculations.  </p><p><strong>Input Arguments</strong></p><ul><li><span>$s::$</span> <code>Complex</code>: the &#39;fractional&#39; parameter</li><li><span>$z$</span> <code>::Complex</code>: the point at which to calculate it</li><li><code>::Diagnostics</code>: use this to indicate that the output should include extra information</li></ul><p><strong>Output Arguments</strong></p><ul><li><span>$Li_s(z)$</span>: The result</li><li><span>$n$</span>:       The number of elements used in each series</li><li><code>series</code>:    The series used to compute results (note this will be a tree when recursion is used</li><li><code>max_recursion</code>:  The maximum depth of recursion used (0 if there is not recursion)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; polylog(0.35, 0.2, Diagnostics() )
(0.23803890574407033, 17, 1, 0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mroughan/Polylogarithms.jl/blob/4cb7747e85fcc7e310e8d23e1635cb8be7b6611b/src/polylog.jl#L91-L121">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Polylogarithms.polylog-Tuple{Number, Number}"><a class="docstring-binding" href="#Polylogarithms.polylog-Tuple{Number, Number}"><code>Polylogarithms.polylog</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">polylog(s, z)</code></pre><p>Calculates the Polylogarithm function <span>${Li}_s(z)$</span> defined by</p><p><span>${Li}_s = \displaystyle  \sum_{n=1}^{\infty} \frac{z^n}{n^s},$</span></p><p>or by analytic extension to the complex plane. </p><p>It uses double precision complex numbers (not arbitrary precision). It&#39;s goal is an relative error bound <span>$10^{-12}$</span> though there is a keyword <code>accuracy</code> that allows you to change this.</p><p><strong>Input Arguments</strong></p><ul><li><span>$s$</span> <code>::Complex</code>: the &#39;fractional&#39; parameter</li><li><span>$z$</span> <code>::Complex</code>: the point at which to calculate it</li></ul><p><strong>Output Arguments</strong></p><ul><li><span>$Li_s(z)$</span>: The result</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; polylog(0.35, 0.2)
0.23803890574407033</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mroughan/Polylogarithms.jl/blob/4cb7747e85fcc7e310e8d23e1635cb8be7b6611b/src/polylog.jl#L56-L80">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Polylogarithms.polylog_ds-Tuple{Number, Number}"><a class="docstring-binding" href="#Polylogarithms.polylog_ds-Tuple{Number, Number}"><code>Polylogarithms.polylog_ds</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">polylog_ds(s, z)</code></pre><p>Derivative of the Polylogarithm function <span>${Li}_s(z)$</span> with respect to s.</p><p>Note that this is not replicating all the work above (yet), and only doing the simple series version which is valid only for |z| &lt; 1.</p><p><strong>Input Arguments</strong></p><ul><li><span>$s$</span> <code>::Complex</code>: the &#39;fractional&#39; parameter</li><li><span>$z$</span> <code>::Complex</code>: the point at which to calculate it</li></ul><p><strong>Output Arguments</strong></p><ul><li><span>$\displaystyle \frac{d}{ds} Li_s(z)$</span></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; polylog_ds(0.35, 0.2)
-0.02947228342617501</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mroughan/Polylogarithms.jl/blob/4cb7747e85fcc7e310e8d23e1635cb8be7b6611b/src/polylog.jl#L792-L812">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Polylogarithms.polylog_dz-Tuple{Number, Number}"><a class="docstring-binding" href="#Polylogarithms.polylog_dz-Tuple{Number, Number}"><code>Polylogarithms.polylog_dz</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">polylog_dz(s, z)</code></pre><p>Derivative of the Polylogarithm function <span>${Li}_s(z)$</span> with respect to z.</p><p>Note that (see eg <a href="https://en.wikipedia.org/wiki/Polylogarithm">https://en.wikipedia.org/wiki/Polylogarithm</a>) <span>$\frac{d}{dz} Li_s(z) = Li_{s-1}(z)/z$</span></p><p><strong>Input Arguments</strong></p><ul><li><span>$s$</span> <code>::Complex</code>: the &#39;fractional&#39; parameter</li><li><span>$z$</span> <code>::Complex</code>: the point at which to calculate it</li></ul><p><strong>Output Arguments</strong></p><ul><li><span>$\displaystyle \frac{d}{dz} Li_s(z)$</span></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; polylog_dz(0.35, 0.2)
1.421095587670745</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mroughan/Polylogarithms.jl/blob/4cb7747e85fcc7e310e8d23e1635cb8be7b6611b/src/polylog.jl#L761-L781">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SpecialFunctions.zeta-Tuple{Number, Memoization}"><a class="docstring-binding" href="#SpecialFunctions.zeta-Tuple{Number, Memoization}"><code>SpecialFunctions.zeta</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">zeta(s, ::Memoization )</code></pre><p>Note that in this library the zeta function has been replaced by a wrapper that looks up (or stores) the value into a cache, so that we don&#39;t have to repeat zeta function calculations. The traditional zeta function will  still work, but the code here uses this one, so performance results will be skewed if you don&#39;t use the cache correctly. </p><p>See also <code>clearcache()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mroughan/Polylogarithms.jl/blob/4cb7747e85fcc7e310e8d23e1635cb8be7b6611b/src/polylog.jl#L34-L42">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Polylogarithms.dilog-Tuple{Number}"><a class="docstring-binding" href="#Polylogarithms.dilog-Tuple{Number}"><code>Polylogarithms.dilog</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dilog(z)</code></pre><p>An alias for the polylogarith with s=2, i.e., <span>${Li}_2(z)$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mroughan/Polylogarithms.jl/blob/4cb7747e85fcc7e310e8d23e1635cb8be7b6611b/src/additional_functions.jl#L42-L46">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Polylogarithms.rogers-Tuple{Number}"><a class="docstring-binding" href="#Polylogarithms.rogers-Tuple{Number}"><code>Polylogarithms.rogers</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rogers(z)</code></pre><p>Calculates Rogers L-function      https://mathworld.wolfram.com/RogersL-Function.html     Directly related to the dilogartihm.</p><p>Note there are two possible versions, we use the one Bytsko, 1999, https://arxiv.org/abs/math-ph/9911012  but note that this is a normalised form (the extra (6/π^2) such that rogers(1)=1) as compared to Rogers (1907)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mroughan/Polylogarithms.jl/blob/4cb7747e85fcc7e310e8d23e1635cb8be7b6611b/src/additional_functions.jl#L1-L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Polylogarithms.spence-Tuple{Number}"><a class="docstring-binding" href="#Polylogarithms.spence-Tuple{Number}"><code>Polylogarithms.spence</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">spence(z)</code></pre><p>An alias for the dilogarith (polylog with s=2), i.e., <span>${Li}_2(z)$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mroughan/Polylogarithms.jl/blob/4cb7747e85fcc7e310e8d23e1635cb8be7b6611b/src/additional_functions.jl#L28-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Polylogarithms.tetralog-Tuple{Number}"><a class="docstring-binding" href="#Polylogarithms.tetralog-Tuple{Number}"><code>Polylogarithms.tetralog</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">tetralog(z)</code></pre><p>An alias for the polylogarith with s=4, i.e., <span>${Li}_4(z)$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mroughan/Polylogarithms.jl/blob/4cb7747e85fcc7e310e8d23e1635cb8be7b6611b/src/additional_functions.jl#L68-L72">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Polylogarithms.trilog-Tuple{Number}"><a class="docstring-binding" href="#Polylogarithms.trilog-Tuple{Number}"><code>Polylogarithms.trilog</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">trilog(z)</code></pre><p>An alias for the polylogarithm with s=3, i.e., <span>${Li}_3(z)$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mroughan/Polylogarithms.jl/blob/4cb7747e85fcc7e310e8d23e1635cb8be7b6611b/src/additional_functions.jl#L55-L59">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Polylogarithms.bernoulli-Tuple{Integer}"><a class="docstring-binding" href="#Polylogarithms.bernoulli-Tuple{Integer}"><code>Polylogarithms.bernoulli</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bernoulli(n)</code></pre><p>Provides a lookup table for the first 59 Bernoulli numbers <span>$B_n$</span>  (of the first-kind or NIST type)   e.g., see</p><ul><li><a href="http://mathworld.wolfram.com/BernoulliNumber.html">http://mathworld.wolfram.com/BernoulliNumber.html</a></li><li><a href="https://en.wikipedia.org/wiki/Bernoulli_number">https://en.wikipedia.org/wiki/Bernoulli_number</a></li><li><a href="http://dlmf.nist.gov/24">http://dlmf.nist.gov/24</a></li><li>Abramowitz and Stegun, Handbook of Mathematical Function, ..., Table 23.2</li></ul><p>N.B. Bernoulli numbers of second kind only seem to differ in that <span>$B_1 = + 1/2$</span> (instead of -1/2)</p><p>There is an algorithmic version of this, but given that the number which are reasonable sized is small, a lookup tables seems fastest. </p><p><strong>Arguments</strong></p><ul><li><span>$n$</span> <code>::Integer</code>: the index into the series, <span>$n=0,1,2,3,...,59$</span> (for larger <span>$n$</span> use <code>bernoulli(n,0.0)</code> )</li></ul><p>The type of the output is Rational{typeof(n)}, so we can only calculate number such that this would not cause  round-off, i.e,</p><table><tr><th style="text-align: right">typeof(n)</th><th style="text-align: right">max_n</th></tr><tr><td style="text-align: right">Int32</td><td style="text-align: right">23</td></tr><tr><td style="text-align: right">Int64</td><td style="text-align: right">35</td></tr><tr><td style="text-align: right">Int128</td><td style="text-align: right">59</td></tr></table><p>Beyond this, it&#39;s probably best to compute the real approximation  using the Bernoulli polynomial, i.e., <code>bernoulli(n,0.0)</code>. </p><p>Harvey has an algorithm used to get n=100,000,000 but this seems overkill for what I need. </p><ul><li>Harvey, David (2010), &quot;A multimodular algorithm for computing Bernoulli numbers&quot;, Math. Comput., 79 (272): 2361–2370, arXiv:0807.1347, doi:10.1090/S0025-5718-2010-02367-1, S2CID 11329343, Zbl 1215.11016</li><li>Apparently implemented in SageMath (since version 3.1)</li></ul><p>But odd values for <span>$n&gt;1$</span> are all zero, so they are easy.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; bernoulli(6)
1//42</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mroughan/Polylogarithms.jl/blob/4cb7747e85fcc7e310e8d23e1635cb8be7b6611b/src/bernoulli_n.jl#L4-L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Polylogarithms.euler-Tuple{Integer}"><a class="docstring-binding" href="#Polylogarithms.euler-Tuple{Integer}"><code>Polylogarithms.euler</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">euler(n)</code></pre><p>Provides a lookup table for the first 60 Euler numbers <span>$E_n$</span>  e.g., see</p><ul><li>Abramowitz and Stegun, Handbook of Mathematical Function, ..., Table 23.2</li><li><a href="https://en.wikipedia.org/wiki/Euler_numbers">https://en.wikipedia.org/wiki/Euler_numbers</a></li></ul><p><strong>Arguments</strong></p><ul><li><span>$n$</span> <code>::Integer</code>: return the nth Euler number</li></ul><p><strong>Notes</strong></p><p>The return type for this is always BigInt</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; euler(40)
14851150718114980017877156781405826684425</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mroughan/Polylogarithms.jl/blob/4cb7747e85fcc7e310e8d23e1635cb8be7b6611b/src/bernoulli_n.jl#L112-L134">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Polylogarithms.bernoulli-Tuple{Integer, Real}"><a class="docstring-binding" href="#Polylogarithms.bernoulli-Tuple{Integer, Real}"><code>Polylogarithms.bernoulli</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bernoulli(n, x)</code></pre><p>Calculates Bernoulli polynomials <span>$B_n(x)$</span>  e.g., see</p><ul><li><a href="https://en.wikipedia.org/wiki/Bernoulli_polynomials">https://en.wikipedia.org/wiki/Bernoulli_polynomials</a></li><li><a href="http://dlmf.nist.gov/24">http://dlmf.nist.gov/24</a></li></ul><p><strong>Arguments</strong></p><ul><li><span>$n$</span> <code>::Integer</code>: the index into the series, <span>$n=0,1,2,3,...$</span></li><li><span>$x$</span> <code>::Real</code>: the point at which to calculate the polynomial</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; bernoulli(6, 1.2)
0.008833523809524735</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mroughan/Polylogarithms.jl/blob/4cb7747e85fcc7e310e8d23e1635cb8be7b6611b/src/bernoulli_poly.jl#L1-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Polylogarithms.harmonic-Tuple{Integer, Integer}"><a class="docstring-binding" href="#Polylogarithms.harmonic-Tuple{Integer, Integer}"><code>Polylogarithms.harmonic</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">harmonic(n::Integer,r::Integer)</code></pre><p>Calculates generalized harmonic numbers    e.g., see <a href="http://mathworld.wolfram.com/HarmonicNumber.html">http://mathworld.wolfram.com/HarmonicNumber.html</a>  using a better approach which works when both inputs are integers    https://carmamaths.org/resources/jon/Preprints/Papers/Published-InPress/Oscillatory%20(Tapas%20II)/Papers/coffey-zeta.pdf</p><p><strong>Arguments</strong></p><ul><li><span>$n$</span> <code>::Integer</code>: non-negative index 1 of the Harmonic number to calculate</li><li><span>$r$</span> <code>::Integer</code>: index 2 of the Harmonic number to calculate</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; harmonic(2,1)
1.4999999999999998</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mroughan/Polylogarithms.jl/blob/4cb7747e85fcc7e310e8d23e1635cb8be7b6611b/src/harmonic.jl#L88-L105">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Polylogarithms.harmonic-Tuple{Integer, Real}"><a class="docstring-binding" href="#Polylogarithms.harmonic-Tuple{Integer, Real}"><code>Polylogarithms.harmonic</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">harmonic(n::Integer,r::Real)</code></pre><p>Calculates generalized harmonic numbers,     e.g., see <a href="http://mathworld.wolfram.com/HarmonicNumber.html">http://mathworld.wolfram.com/HarmonicNumber.html</a></p><p><strong>Arguments</strong></p><ul><li><span>$n$</span> <code>::Integer</code>: non-negative index 1 of the Harmonic number to calculate</li><li><span>$r$</span> <code>::Real</code>: index 2 of the Harmonic number to calculate</li></ul><p>It should be possible to extend this to complex r, but that requires more testing.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; harmonic(2,1.5)
1.3535533905932737</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mroughan/Polylogarithms.jl/blob/4cb7747e85fcc7e310e8d23e1635cb8be7b6611b/src/harmonic.jl#L53-L70">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Polylogarithms.harmonic-Tuple{Integer}"><a class="docstring-binding" href="#Polylogarithms.harmonic-Tuple{Integer}"><code>Polylogarithms.harmonic</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">harmonic(n::Integer)</code></pre><p>Calculates harmonic numbers,    e.g., see <a href="http://mathworld.wolfram.com/HarmonicNumber.html">http://mathworld.wolfram.com/HarmonicNumber.html</a></p><p><strong>Arguments</strong></p><ul><li><span>$n$</span> <code>::Integer</code>: non-negative index of the Harmonic number to calculate</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; harmonic(2)
1.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mroughan/Polylogarithms.jl/blob/4cb7747e85fcc7e310e8d23e1635cb8be7b6611b/src/harmonic.jl#L1-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Polylogarithms.harmonic-Tuple{Union{Float64, ComplexF64}}"><a class="docstring-binding" href="#Polylogarithms.harmonic-Tuple{Union{Float64, ComplexF64}}"><code>Polylogarithms.harmonic</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">harmonic(x::ComplexOrReal{Float64})</code></pre><p>Calculates harmonic numbers extended to non-integer arguments using the  digamma form.</p><p><strong>Arguments</strong></p><ul><li><span>$x$</span> <code>::ComplexOrReal{Float64}</code>: index of the Harmonic number to calculate</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; harmonic(2.0)
1.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mroughan/Polylogarithms.jl/blob/4cb7747e85fcc7e310e8d23e1635cb8be7b6611b/src/harmonic.jl#L33-L47">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Polylogarithms.stieltjes-Tuple{Integer}"><a class="docstring-binding" href="#Polylogarithms.stieltjes-Tuple{Integer}"><code>Polylogarithms.stieltjes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">stieltjes(n)</code></pre><p>Provides the first 79 Stieltjes (generalized Euler-Mascheroni) constants (see  Abramowitz and Stegunm, 23.2.5) or <a href="https://en.wikipedia.org/wiki/Stieltjes_constants">https://en.wikipedia.org/wiki/Stieltjes_constants</a>.</p><p>There is a table at &quot;The Generalized Euler-Mascheroni Constants&quot;, O.R. Ainsworth and L.W.Howell  NASA Technical Paper 2264, Jan 1984  <a href="https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19840007812.pdf">https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19840007812.pdf</a>  but the OEIS has more accurate values, which will be useful when I get around to   bit float versions of the code. More recently found      <a href="http://www.plouffe.fr/simon/constants/stieltjesgamma.txt">http://www.plouffe.fr/simon/constants/stieltjesgamma.txt</a>, which has first 78 to 256 digits. Obviously most digits are wasted at the moment, but that can change later. </p><p>Note that stieltjes(0) = γ, the Euler–Mascheroni constant, also called just Euler&#39;s constant.   <a href="https://en.wikipedia.org/wiki/Euler%E2%80%93Mascheroni_constant">https://en.wikipedia.org/wiki/Euler-Mascheroni_constant</a></p><p><strong>Arguments</strong></p><ul><li><code>n::Integer</code>: the number of elements to compute.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; stieltjes(0)
0.5772156649015329</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mroughan/Polylogarithms.jl/blob/4cb7747e85fcc7e310e8d23e1635cb8be7b6611b/src/stieltjes.jl#L133-L157">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Polylogarithms.dirichlet_beta-Tuple{Number}"><a class="docstring-binding" href="#Polylogarithms.dirichlet_beta-Tuple{Number}"><code>Polylogarithms.dirichlet_beta</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dirichlet_beta()</code></pre><p>Calculates Dirichlet beta function,      <a href="https://en.wikipedia.org/wiki/Dirichlet_beta_function">https://en.wikipedia.org/wiki/Dirichlet<em>beta</em>function</a></p><p><strong>Arguments</strong></p><ul><li><span>$s$</span> <code>::Number</code>: it should work for any type of number, but mainly tested for <code>Complex{Float64}</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; dirichlet_beta(1.5)
0.8645026534612017</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mroughan/Polylogarithms.jl/blob/4cb7747e85fcc7e310e8d23e1635cb8be7b6611b/src/beta.jl#L1-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.parse-Union{Tuple{T}, Tuple{Type{Complex{T}}, AbstractString}} where T&lt;:Real"><a class="docstring-binding" href="#Base.parse-Union{Tuple{T}, Tuple{Type{Complex{T}}, AbstractString}} where T&lt;:Real"><code>Base.parse</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>parse(::Type{Complex{T}}, s::AbstractString) where {T&lt;:Real}</p><p>Parse complex numbers.</p><ul><li><p>This code doesn&#39;t deal with all possible forms of complex numbers, just those output by Mathematica</p></li><li><p>But, latest version of Mathematica seems to have gone over to a more standard form, so this has been modded</p></li></ul><p><strong>Arguments</strong></p><ul><li><code>::Type{Complex{T}}</code>: the type to parse to, where T is a Real number type</li><li><code>s::AbstractString</code>: the string to parse</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; parse( Complex{Float64}, &quot;1.2 - 3.1*I&quot;)
1.2 - 3.1im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mroughan/Polylogarithms.jl/blob/4cb7747e85fcc7e310e8d23e1635cb8be7b6611b/src/utilities.jl#L3-L21">source</a></section></details></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 26 November 2025 23:17">Wednesday 26 November 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
