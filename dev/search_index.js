var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"","category":"section"},{"location":"#Polylogarithms","page":"Home","title":"Polylogarithms","text":"","category":"section"},{"location":"#Polylogarithms.Polylogarithms","page":"Home","title":"Polylogarithms.Polylogarithms","text":"Polylogarithms\n\nModule containing functions to calculate the polylogarithm and associated functions\n\n\n\n\n\n","category":"module"},{"location":"#Polylogarithms.clearcache-Tuple{}","page":"Home","title":"Polylogarithms.clearcache","text":"clearcache()\n\nNote that in this library the zeta function has been replaced by a wrapper that looks up (or stores) the value into a cache, so that we don't have to repeat zeta function calculations. This function clears the cache so that you can obtain accurate \"first run\" performance measurements. It should not be needed in day-to-day calculations unless it is used a great deal and the cache starts taking up too much memory. \n\nSee also zeta(s, ::Memoization ).\n\n\n\n\n\n","category":"method"},{"location":"#Polylogarithms.polylog-Tuple{Number, Number, Diagnostics}","page":"Home","title":"Polylogarithms.polylog","text":"polylog(s, z, Diagnostics())\n\nCalculates the Polylogarithm function Li_s(z) defined by\n\nLi_s = displaystyle  sum_n=1^infty fracz^nn^s\n\nor by analytic expension to the complex plane. \n\nIt uses double precision complex numbers (not arbitrary precision). It's goal is an relative error bound 10^{-12}.\n\nThis version outputs some additional diagnostic information that is useful in debugging, but unlikely to be useful in everyday calculations. \n\nInput Arguments\n\ns Complex: the 'fractional' parameter\nz ::Complex: the point at which to calculate it\n::Diagnostics: use this to indicate that the output should include extra information\n\nOutput Arguments\n\nLi_s(z): The result\nn:       The number of elements used in each series\nseries:    The series used to compute results (note this will be a tree when recursion is used\nmax_recursion:  The maximum depth of recursion used (0 if there is not recursion)\n\nExamples\n\njulia> polylog(0.35, 0.2, Diagnostics() )\n(0.23803890574407033, 17, 1, 0)\n\n\n\n\n\n","category":"method"},{"location":"#Polylogarithms.polylog-Tuple{Number, Number}","page":"Home","title":"Polylogarithms.polylog","text":"polylog(s, z)\n\nCalculates the Polylogarithm function Li_s(z) defined by\n\nLi_s = displaystyle  sum_n=1^infty fracz^nn^s\n\nor by analytic expension to the complex plane. \n\nIt uses double precision complex numbers (not arbitrary precision). It's goal is an relative error bound 10^{-12}.\n\nInput Arguments\n\ns ::Complex: the 'fractional' parameter\nz ::Complex: the point at which to calculate it\n\nOutput Arguments\n\nLi_s(z): The result\n\nExamples\n\njulia> polylog(0.35, 0.2)\n0.23803890574407033\n\n\n\n\n\n","category":"method"},{"location":"#Polylogarithms.polylog_ds-Tuple{Number, Number}","page":"Home","title":"Polylogarithms.polylog_ds","text":"polylog_ds(s, z)\n\nDerivative of the Polylogarithm function Li_s(z) with respect to s.\n\nNote that this is not replicating all the work above (yet), and only doing the simple series version which is valid only for |z| < 1.\n\nInput Arguments\n\ns ::Complex: the 'fractional' parameter\nz ::Complex: the point at which to calculate it\n\nOutput Arguments\n\ndisplaystyle fracdds Li_s(z)\n\nExamples\n\njulia> polylog_ds(0.35, 0.2)\n-0.02947228342617501\n\n\n\n\n\n","category":"method"},{"location":"#Polylogarithms.polylog_dz-Tuple{Number, Number}","page":"Home","title":"Polylogarithms.polylog_dz","text":"polylog_dz(s, z)\n\nDerivative of the Polylogarithm function Li_s(z) with respect to z.\n\nNote that (see eg https://en.wikipedia.org/wiki/Polylogarithm) fracddz Li_s(z) = Li_s-1(z)z\n\nInput Arguments\n\ns ::Complex: the 'fractional' parameter\nz ::Complex: the point at which to calculate it\n\nOutput Arguments\n\ndisplaystyle fracddz Li_s(z)\n\nExamples\n\njulia> polylog_dz(0.35, 0.2)\n1.421095587670745\n\n\n\n\n\n","category":"method"},{"location":"#SpecialFunctions.zeta-Tuple{Number, Memoization}","page":"Home","title":"SpecialFunctions.zeta","text":"zeta(s, ::Memoization )\n\nNote that in this library the zeta function has been replaced by a wrapper that looks up (or stores) the value into a cache, so that we don't have to repeat zeta function calculations. The traditional zeta function will  still work, but the code here uses this one, so performance results will be skewed if you don't use the cache correctly. \n\nSee also clearcache().\n\n\n\n\n\n","category":"method"},{"location":"#Polylogarithms.dilog-Tuple{Number}","page":"Home","title":"Polylogarithms.dilog","text":"dilog(z)\n\nAn alias for the polylogarith with s=2, i.e., Li_2(z)\n\n\n\n\n\n","category":"method"},{"location":"#Polylogarithms.rogers-Tuple{Number}","page":"Home","title":"Polylogarithms.rogers","text":"rogers(z)\n\nCalculates Rogers L-function      https://mathworld.wolfram.com/RogersL-Function.html     Directly related to the dilogartihm.\n\nNote there are two possible versions, we use the one Bytsko, 1999, https://arxiv.org/abs/math-ph/9911012  but note that this is a normalised form (the extra (6/π^2) such that rogers(1)=1) as compared to Rogers (1907)\n\n\n\n\n\n","category":"method"},{"location":"#Polylogarithms.spence-Tuple{Number}","page":"Home","title":"Polylogarithms.spence","text":"spence(z)\n\nAn alias for the dilogarith (polylog with s=2), i.e., Li_2(z)\n\n\n\n\n\n","category":"method"},{"location":"#Polylogarithms.tetralog-Tuple{Number}","page":"Home","title":"Polylogarithms.tetralog","text":"tetralog(z)\n\nAn alias for the polylogarith with s=4, i.e., Li_4(z)\n\n\n\n\n\n","category":"method"},{"location":"#Polylogarithms.trilog-Tuple{Number}","page":"Home","title":"Polylogarithms.trilog","text":"trilog(z)\n\nAn alias for the polylogarithm with s=3, i.e., Li_3(z)\n\n\n\n\n\n","category":"method"},{"location":"#Polylogarithms.bernoulli-Tuple{Integer}","page":"Home","title":"Polylogarithms.bernoulli","text":"bernoulli(n)\n\nProvides a lookup table for the first 59 Bernoulli numbers B_n  (of the first-kind or NIST type)   e.g., see\n\nhttp://mathworld.wolfram.com/BernoulliNumber.html\nhttps://en.wikipedia.org/wiki/Bernoulli_number\nhttp://dlmf.nist.gov/24\nAbramowitz and Stegun, Handbook of Mathematical Function, ..., Table 23.2\n\nN.B. Bernoulli numbers of second kind only seem to differ in that B_1 = + 12 (instead of -1/2)\n\nThere is an algorithmic version of this, but given that the number which are reasonable sized is small, a lookup tables seems fastest. \n\nArguments\n\nn ::Integer: the index into the series, n=012359 (for larger n use bernoulli(n,0.0) )\n\nThe type of the output is Rational{typeof(n)}, so we can only calculate number such that this would not cause  round-off, i.e, | typeof(n) | max_n | |–––––|––––| | Int32    | 23     | | Int64    | 35     | | Int128   | 59     |\n\nBeyond this, its probably best to compute the real approximation  using the Bernoulli polynomial, i.e., bernoulli(n,0.0). \n\nHarvey has an algorithm used to get n=100,000,000 but this seems overkill for what I need. \n\nHarvey, David (2010), \"A multimodular algorithm for computing Bernoulli numbers\", Math. Comput., 79 (272): 2361–2370, arXiv:0807.1347, doi:10.1090/S0025-5718-2010-02367-1, S2CID 11329343, Zbl 1215.11016\nApparently implemented in SageMath (since 3.1)\n\nBut odd values for n1 are all zero, so they are easy.\n\nExamples\n\njulia> bernoulli(6)\n1//42\n\n\n\n\n\n","category":"method"},{"location":"#Polylogarithms.euler-Tuple{Integer}","page":"Home","title":"Polylogarithms.euler","text":"euler(n)\n\nProvides a lookup table for the first 60 Euler numbers E_n  e.g., see\n\nAbramowitz and Stegun, Handbook of Mathematical Function, ..., Table 23.2\nhttps://en.wikipedia.org/wiki/Euler_numbers\n\nArguments\n\nn ::Integer: return the nth Euler number\n\nNotes\n\nThe return type for this is always BigInt\n\nExamples\n\njulia> bernoulli(6)\n1//42\n\n\n\n\n\n","category":"method"},{"location":"#Polylogarithms.bernoulli-Tuple{Integer, Real}","page":"Home","title":"Polylogarithms.bernoulli","text":"bernoulli(n, x)\n\nCalculates Bernoulli polynomials B_n(x)  e.g., see\n\nhttps://en.wikipedia.org/wiki/Bernoulli_polynomials\nhttp://dlmf.nist.gov/24\n\nArguments\n\nn ::Integer: the index into the series, n=0123\nx ::Real: the point at which to calculate the polynomial\n\nExamples\n\njulia> bernoulli(6, 1.2)\n0.008833523809524735\n\n\n\n\n\n","category":"method"},{"location":"#Polylogarithms.harmonic-Tuple{Integer, Integer}","page":"Home","title":"Polylogarithms.harmonic","text":"harmonic(n::Integer,r::Integer)\n\nCalculates generalized harmonic numbers    e.g., see http://mathworld.wolfram.com/HarmonicNumber.html  using a better approach which works when both inputs are integers    https://carmamaths.org/resources/jon/Preprints/Papers/Published-InPress/Oscillatory%20(Tapas%20II)/Papers/coffey-zeta.pdf\n\nArguments\n\nn ::Integer: non-negative index 1 of the Harmonic number to calculate\nr ::Integer: index 2 of the Harmonic number to calculate\n\nExamples\n\njulia> harmonic(2,1)\n1.4999999999999998\n\n\n\n\n\n","category":"method"},{"location":"#Polylogarithms.harmonic-Tuple{Integer, Real}","page":"Home","title":"Polylogarithms.harmonic","text":"harmonic(n::Integer,r::Real)\n\nCalculates generalized harmonic numbers,     e.g., see http://mathworld.wolfram.com/HarmonicNumber.html\n\nArguments\n\nn ::Integer: non-negative index 1 of the Harmonic number to calculate\nr ::Real: index 2 of the Harmonic number to calculate\n\nIt should be possible to extend this to complex r, but that requires more testing.\n\nExamples\n\njulia> harmonic(2,1.5)\n1.3535533905932737\n\n\n\n\n\n","category":"method"},{"location":"#Polylogarithms.harmonic-Tuple{Integer}","page":"Home","title":"Polylogarithms.harmonic","text":"harmonic(n::Integer)\n\nCalculates harmonic numbers,    e.g., see http://mathworld.wolfram.com/HarmonicNumber.html\n\nArguments\n\nn ::Integer: non-negative index of the Harmonic number to calculate\n\nExamples\n\njulia> harmonic(2)\n1.5\n\n\n\n\n\n","category":"method"},{"location":"#Polylogarithms.harmonic-Tuple{Union{Float64, ComplexF64}}","page":"Home","title":"Polylogarithms.harmonic","text":"harmonic(x::ComplexOrReal{Float64})\n\nCalculates harmonic numbers extended to non-integer arguments using the  digamma form.\n\nArguments\n\nx ::ComplexOrReal{Float64}: index of the Harmonic number to calculate\n\nExamples\n\njulia> harmonic(2.0)\n1.5\n\n\n\n\n\n","category":"method"},{"location":"#Polylogarithms.stieltjes-Tuple{Integer}","page":"Home","title":"Polylogarithms.stieltjes","text":"stieltjes(n)\n\nProvides the first 79 Stieltjes (generalized Euler-Mascheroni) constants (see  Abramowitz and Stegunm, 23.2.5) or https://en.wikipedia.org/wiki/Stieltjes_constants.\n\nThere is a table at \"The Generalized Euler-Mascheroni Constants\", O.R. Ainsworth and L.W.Howell  NASA Technical Paper 2264, Jan 1984  https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19840007812.pdf  but the OEIS has more accurate values, which will be useful when I get around to   bit float versions of the code. More recently found      http://www.plouffe.fr/simon/constants/stieltjesgamma.txt, which has first 78 to 256 digits. Obviously most digits are wasted at the moment, but that can change later. \n\nNote that stieltjes(0) = γ, the Euler–Mascheroni constant, also called just Euler's constant.   https://en.wikipedia.org/wiki/Euler-Mascheroni_constant\n\nArguments\n\nn::Integer: the number of elements to compute.\n\nExamples\n\njulia> stieltjes(0)\n0.5772156649015329\n\n\n\n\n\n","category":"method"},{"location":"#Polylogarithms.dirichlet_beta-Tuple{Number}","page":"Home","title":"Polylogarithms.dirichlet_beta","text":"dirichlet_beta()\n\nCalculates Dirichlet beta function,      https://en.wikipedia.org/wiki/Dirichletbetafunction\n\nArguments\n\ns ::Number: it should work for any type of number, but mainly tested for Complex{Float64}\n\nExamples\n\njulia> dirichlet_beta(1.5)\n0.8645026534612017\n\n\n\n\n\n","category":"method"},{"location":"#Base.parse-Union{Tuple{T}, Tuple{Type{Complex{T}}, AbstractString}} where T<:Real","page":"Home","title":"Base.parse","text":"parse(::Type{Complex{T}}, s::AbstractString) where {T<:Real}\n\nParse complex numbers.\n\nThis code doesn't deal with all possible forms of complex numbers, just those output by Mathematica\nBut, latest version of Mathematica seems to have gone over to a more standard form, so this has been modded\n\nArguments\n\n::Type{Complex{T}}: the type to parse to, where T is a Real number type\ns::AbstractString: the string to parse\n\nExamples\n\njulia> parse( Complex{Float64}, \"1.2 - 3.1*I\")\n1.2 - 3.1im\n\n\n\n\n\n","category":"method"}]
}
